[TOC]

#### C++部分

##### 1.堆和栈的区别

>
>
>

##### 2.构造函数可以是虚函数吗，析构函数呢？

>当然不能。一定要解释：
>
>1. **存储空间**：虚函数是通过虚函数表实现的，虚函数表是存储在对象的内存空间中的，如果构造函数是虚的，那么就要通过虚函数表来调用，问题是对象还没有实例化，内存空间还没有，根本无法调用虚函数表。
>2. **使用逻辑**：虚函数主要用于信息不全的情况下，使重载的函数能够得到相应的调用，构造函数本身就是构建对象实例，使用虚函数没有没有意义，使用虚函数形式的构造函数没有意义。
>3. 虚函数的作用是通过父类的指针或引用来调用对象的时候能够自动调用子类的成员函数，而构造函数是在创建对象时候自动调用的，不可能通过父类的指针或者引用去调用，所以构造函数不能是虚函数。
>
>但是析构函数最好声明为虚函数：
>
>* 如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。

##### 3.STL容器的效率问题

>vector内部使用动态数组实现，进行insert和push_back的时候，如果动态数组的内存不够用，那么就要动态地重新分配当前大小的1.5~2倍的新内存区，并把原数组进行复制进去，这是非常耗时的。因此，如果大量的数据需要添加，因该提前使用`reserve()`来设定较大容量，从而避免反复分配导致的效率下降。

##### 4.STL容器迭代器失效问题

>
>
>

##### 5.关于Static关键字的作用

>static静态声明，从作用域、存储方式和生命周期各方面影响一个变量或函数。分别如下：
>
>1. 全局变量：全局变量本身，无论是否声明static，都是静态存储的，将全局变量声明为static是为了将变量的作用域限制在本源文件内，从而不能被其他源程序使用。**static改变全局变量的作用域，而不改变存储位置和生命周期。**
>2. 局部变量：局部变量生命为static之后，存在于程序运行的整个过程，普通局部变量存储在栈区，而static局部变量存在于静态存储区。**static改变了局部变量的存储方式与生命周期，而不改变其作用域。**
>3. 普通函数：函数定义时默认在外部，通过extern即可被其它源文件引用，static声明将函数作用域限定在了本文件中，成为内部函数。**static函数使得函数在内存中只有一份，而普通函数在每个调用中维持一份拷贝。**
>4. 类成员：静态成员是每个类有一份，而普通成员是每个实例对象有一份，因此又称为**类变量**，而普通成员成为**实例变量**。
>5. 类成员函数：类的静态成员函数可以使用类名::函数名进行访问，因为它不属于类对象，没有this指针（也可以通过类实例对象调用）。static类函数可以访问类静态成员，但是不能访问普通函数和成员，因为其它成员（实例）此时还没有创建。另一方面，普通成员函数可以访问静态函数和成员，因为静态成员一直存在。使用总结如下：
>
>**初始化**：
>
>1. 静态局部变量一般在声明处初始化，如果没有显式初始化，会有默认值，初始一次之后下次再调用函数就不会初始化了，因为内存中已经有了。
>2. 静态类成员由于定义的时候就要分配内存空间，所以不能再类的声明中（构造函数）定义，而必须在类定义体的外部进行定义。
>
>**优点**：
>
>1. 和全局变量相比，虽然生命周期一样，但是static局部变量仍然属于函数，受函数的控制，维护方便。
>2. 静态变量可以对全局变量和函数起到屏蔽作用，避免了链接时与其它源文件中的变量名引起冲突。

##### 6.虚函数可以声明为static吗?

>当然不可以，static成员函数没有this指针，虚函数运行时绑定的是多态的基础，没有this指针根本无法实现多态。

##### 7.解释下虚函数的实现机制

>虚函数通过虚函数表和虚表指针实现。编译器为每个**类对象**添加一个隐藏成员，隐藏成员中保存了一个**指向函数地址数组的指针**，称为虚表指针(vptr)，这个数组称为虚函数表(vtable)。即，每个类使用一个虚函数表，每个实例对象都存储一个虚表指针。
>
>* 如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，**而不是**基类的虚函数地址。
>* 如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类的虚方法，虚函数表将保存基类中未被重写的虚函数地址。而且派生类中新定义的虚函数地址也会被添加进虚函数表。

##### 8.类的成员函数可以同时声明为const和static吗？

>当然不可以，编译器在实现const成员函数时，为了确保该函数不能修改该类的实例状态，会在函数中添加一个隐式的参数 const this*。但当一个 成员为static的时候，函数是没有this指针的，也就是说const和static此时的用法是冲突的。

#### 数据结构

##### 1.哈希表和红黑树的对比

>STL中的map是基于红黑树实现的，查找速度为$O(\lg n)​$ 级别的，和哈希表对比如下：
>
>1. 哈希查找的速度比红黑树快，而且查找速度基本和数据量大小无关，但是并不一定就比红黑树的$O(\lg n)$ 差，因为hash还有hash 函数的耗时。
>2. 红黑树占用的内存相对于hash更少，在C++中用于实现set和map。红黑树并不适应于所有树的领域，如果数据基本是静态的，那么使用插入方便，不影响平衡的数据结构比较好。如果数据是完全静态的，做一个哈希表，性能会更好一点。
>3. 红黑树是有序的，哈希表是无序的。如果只需要判断map中某个值是否存在之类的操作，那么哈希实现的要更加高效。如果要将两个map求并集、交集、差集等大量比较操作，那么红黑树实现的map更加高效。

##### 2.红黑树常见问题

>红黑树的结构定义
>
>```c++
>enum Color{ RED = 0, BLACK = 1};
>struct RBTreeNode{
>    RBTreeNode *left,*right,*parent;
>    int key;
>    int data;
>    Color color;
>};
>```
>
>**红黑树的性质：**
>
>1. 结点要么是红的，要么是黑的；
>2. 根节点是黑的；
>3. 每个叶节点是黑的；
>4. 如果一个结点是红的，那么它的两个儿子是黑的；
>5. 对任一节点而言，其叶节点树尾端NIL指针的每一条路径都包含相同数目的黑结点。
>
>**时间复杂度：**
>
>可以保证在最坏的情况下，基本的动态几何操作的时间均为$O(\lg n)$ 。
>
>**相对于BST和AVL树有什么优点：**
>
>* 红黑树**牺牲了严格的高度平衡的优越条件，只要求部分地达到平衡要求**，降低了对旋转的要求，从而提高了性能。红黑树能够以$O(\lg_2 n)$ 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都可以在三次旋转之内解决。
>* 红黑树能确保树的最长路径不大于两倍的最短路径的长度，所以它的查找效率是有保证的。在最坏的情况下也可以保证，这是优于二叉搜索树的。

##### 3.hash_map的原理

>C++中的hash_map是基于hash table，其基本原理是：使用一个下标范围比较大的数组来存储元素，可以设计一个函数（哈希函数），使得每个元素的关键字都与一个函数值（数组下标，哈希值）相对应，利用这个数组单元存储这个元素。可以理解为按照关键字为每个元素分类，然后将这个元素存储在相应的“类”对应的地方，成为桶。

##### 4.STL中map,hash_map和unordered_map的实现及优缺点

>map： 
>
>* 优点： 
>  1. 有序性：这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作；
>     红黑树，内部实现一个红黑书使得 map 的很多操作在 log n 的时间复杂度下就可以实现，因此效率非常的高；
>  2. 缺点： 
>     空间占用率高，因为 map 内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，子节点以及红/黑性质，使得每一个节点都占用大量的空间；
>
>- 适用于具有顺序要求的问题；
>
>hash_map： 
>
>* 优点： 
>  1. hash_map 查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别（但不能说一定比 map 的 log n 级别快，因为 hash 函数本身也有耗时）；
>  2. 缺点： 
>     空间占用多，如果对内存使用很严格，需要认真考虑是否使用 hash_map ；特别是当 hash_map 对象特别多时，更加难以控制
>
>* 适用于对效率要求较高的环境；
>
>unordered_map
>
>1. 优点：
>
>    内部实现了 Hash 表，所以查找速度很快；
>
>2. 缺点：
>
>   Hash 表的建立比较比较费时；
>
>​	适用于查找问题；
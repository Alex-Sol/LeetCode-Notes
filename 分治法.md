## 1.设计原理

递归的求解每一个问题，在每层递归中应用三个步骤：

**分解divide**：将问题划分为一些子问题，子问题形式与原问题一样，只是规模更小；

**解决conquer**:递归的求解出子问题，如果子问题的规模足够小，则停止递归，直接求解；

**合并combine**:将子问题的解组合成原问题的解。

当子问题的规模足够大时，需要使用递归求解，称之为recursive case。当子问题的变得足够小，不再需要递归时，即已经触底，进入了base case。

### 1.1循环不变式

证明一个算法成立，必须证明三条性质

**初始化**：循环的第一次迭代之前，它为真。

**保持**：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。

**终止**：再循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。

第三条性质是最重要的，通常和导致循环终止的条件一起使用循环不变式，这也是和数学归纳法最大的不同。

### 1.2 求解

#### 1.代入法

代入法就是先猜测解的形式，再用数学归纳法球出界中的常数，并且证明解是正确的。例如使用代入法为递归式建立上界：
$$
T(n)=2T(\lfloor n/2\rfloor)+n
$$
**猜想**：存在常数c使得$T(n)\leq cn\lg n$，且该式对所有正数$m<n$均成立。

**归纳**：代入递归式可得：
$$
T(n)\leq 2(c\lfloor n/2 \rfloor \lg (\lfloor n/2 \rfloor))+n\leq
cn\lg (n/2)+n \\
=cn\lg n -cn \lg 2+n\\
=cn \lg n -cn +n \leq cn\lg n
$$
只要$c\geq1$最后一步就成立。

有时候，给定的边界条件在猜想中不成立，这是，我们可以扩展边界条件。例如，$T(1)=1$是给定边界条件，但是$T(1)\leq c*\lg 1=0$，显然不成立，因此，将边界条件扩展为$n\geq n_0$时,$T(n)\leq cn\lg n$，令$n_0=2  或  3$。应该看到，做出不同的归纳假设，可以不用调整边界条件，例如$T(n)\leq 2n\lg n+1$。

**细节**：有时候才出了递归式的渐进界，但是证明时失败了，有可能是因为缺少了相应的低阶项。例如：
$$
T(n)=T(\lfloor n/2 \rfloor)+T(\lceil n/2 \rceil)+1
$$
猜测解为$T(n)=O(n),T(n)\leq cn$成立。但是只能得到$T(n)\leq cn+1$。这样的证明仍然是失败的，必须形式严格一致。这是增加一个低阶项，猜测$T(n)\leq cn-d$，得到：
$$
T(n)\leq (c\lfloor n/2 \rfloor-d)+(c\lceil n/2 \rceil-d)+1\\
=cn-2d+1\leq cn-d
$$
只要d>=1，这式就能成立。

**例1**：$T(n)=T(n-1)+n$

Assume: $T(n)\leq cn^2, c=\max(1,T(1))$

Derive:$T(n)\leq c(n-1)^2+n=cn^2+(1-2c)n+1\leq cn^2+2-2c\leq cn^2$

**例2**：$T(n)=T(\lceil n/2 \rceil)+1$

Assume: $T(n)\leq 3\log n-1$

Derive:$T(n)\leq 3\log(\lceil n/2 \rceil)-1+1\leq 3\log(3n/4)=3\log n +3\log (3/4)\leq3\log n-1$

#### 2.递归树法

以$T(n)=3T(\lfloor n/4 \rfloor)+\Theta(n^2)$为例，首先假定$n=4^i$，既可以得到树的深度为$0,1,...,\log_4n$，深度为0代表规模为n，尚没有划分，经过 $i$ 次的划分最后一层每个子问题的规模都是1，从而不能再继续划分，到达了递归的终止条件。要关注的量有两个：

* 每一层子问题的个数；
* 每个子问题的规模。

后面的$\Theta(n^2)$则给出了子问题的规模和子问题时间复杂度的关系，有了这三个要素之后，就可以分别算出每一层子问题的时间复杂度，各层进行求和。以上式为例，第$i$层有$3^i$个子问题，每个子问题的规模是$n/4^i$，每个子问题的时间复杂度为$c(n/4^i)^2$。从而每层的时间复杂度为
$$
3^ic(n/4^i)^2=(3/16)^icn^2
$$
最后一层共有$3^{\log_4n}=n^{\log_43}$个节点，每个节点的代价为$T(1)$，整棵树代价为：
$$
T(n)=\sum\limits_{i=0}^{\log_4 n-1}(\frac{3}{16})^icn^2+\Theta(n^{\log_43})=O(n^2)
$$

#### 3.主定理法

**定理**：令$a\geq 1$和$b>1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式：$T(n)=aT(n/b)+f(n)$，其中$n/b$可以解释为$\lfloor n/b \rfloor$或$\lceil n/b \rceil$，那么$T(n)$有如下的渐进界：

1. 若对于某个常数$\epsilon>0$，有$f(n)=O(n^{\log_b a-\epsilon})$,则$T(n)=\Theta(n^{\log_b a})$
2. 若$f(n)=O(n^{\log_b a})$，则$T(n)=\Theta(n^{\log_b a})$
3. 若对于某个常数$\epsilon>0$有$f(n)=\Omega(n^{\log_b a})$，且对于某个常数$c<1$何所有足够大的$n$有$af(n/b)\leq cf(n)$，则$T(n)=\Theta(f(n))$。

对于三种情况的每一种，都是将$f(n)$与$n^{\log_b a}$进行比较，直觉上两者较大者决定了递归式的解。但是，这里的大于小于是多项式意义上的，渐进性地大于小于，而且要相差一个常数因子。在第三种情况下，还要满足正则条件。
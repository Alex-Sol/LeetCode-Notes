*--- 再怎么焦虑，路还是得一步一步的走，一口吃不成个汪的。*

### 1.树的定义

树是典型的一对多的数据结构。树由结点组成，树的结点包含一个数据元素以及若干指向其子树的分支。结点拥有的子树称为节点的==度==，度为0称为叶节点，度不为0称为分支结点。除根节点外，分支结点也被称为内部节点。

### 2.树的存储

#### 1.顺序表存储

虽然使用指针更加的方便，但是利用父结点与子结点之间的逻辑关系，可以使用顺序表来存储一个树。下面介绍三种表示方法：双亲表示法、孩子表示法、孩子兄弟表示法。

##### 双亲表示法

data 表示数据域，parent是指针域，存储双亲在数组的下标。

```c++
#define MAX_TREE_SIZE 100
typedef int TElemType;
typedef struct PTNode
{
    TElemType data;
    int parent;
} PTNode;
typedef struct
{
    PTNode nodes[MAX_TREE_SIZE];
    int r,n;
} PTree;
```

由于根节点没有双亲，我们使用`-1`表示父节点的下标。

时间特性：`parent()`时间复杂度为O(1)，但是寻找孩子节点`children()`时间复杂度为O(n)。

>此时没有限定是完全二叉树，只有完全二叉树才有关系：2n+1, 2n+2的关系。

##### 孩子表示法

由于每个结点的度不一样，表示一个结点所有的孩子结点指针时，我们把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，此时，显然有叶子结点的单链表为空。n个头指针组成一个线性表，采用顺序存储结构，存放进一个数组中。

为此，我们设计两个结点结构，一个是孩子链表的孩子结点（child+next），一个是表头数组的表头结点（data+firstchild）。

![1551761212119](C:\Users\邢富\AppData\Roaming\Typora\typora-user-images\1551761212119.png)

```c++
#define MAX_TREE_SIZE 100
typedef struct CTNode // 孩子结点
{
    int child;
    struct CTNode *next;
} *ChildPtr;

typedef struct //表头结构
{
    TElemType data;
    ChildPtr firstchild;
} CTBox;

typedef struct
{
    CTBox nodes[MAX_TREE_SIZE];
    int r,n;
} CTree;
```

这时，查找某个结点的孩子很方便，但是查找父节点比较困难了，可以改进为孩子双亲表示法。

##### 孩子双亲表示法

### 二叉树

#### 定义

首先明白==完全二叉树==的定义，最常用的类型，如果一个二叉树所有的叶节点都在最后一层，那么叫做满二叉树，如果编号为$i$ 的结点与同样深度的满二叉树中编号为$i$ 的结点在二叉树中的位置完全相同，那么称为==完全二叉树==。

完全二叉树特点如下：

1. 叶子结点只存在最下两层；
2. 最下层的叶子一定集中在左部的连续位置；
3. 如果结点度数为1，那么一定有左孩子，而没有右孩子；
4. 同样节点的二叉树，完全二叉树的深度最小。

#### 性质

性质1.在二叉树的第$i$ 层，至多有 $2^{i-1}$ 个结点。

性质2.深度为$h$ 的二叉树最多有 $2^h-1$ 个结点。

<u>性质3.对于一个二叉树，如果其叶子节点数为$n_0$，度为2的结点数为 $n_2$ ，那么$ n_0=n_2+1$。</u>

性质4.具有$n$ 个结点的完全二叉树的深度为 $|\log_2 n|+1$。

性质5.如果一颗完全二叉树的结点按层进行编号，那么对于任意结点$i$ 有：

1. 如果$i=1$，为根节点；如果$i>1$，父节点为$|i/2|$；
2. 左孩子节点为$2i+1$，右孩子节点为$2i+2$。

#### 存储

利用上面的性质，很容易使用顺序存储结构来存储完全二叉树，直接使用数组下边来访问父节点、孩子结点，而不用单独存储地址。

![1551762936696](C:\Users\邢富\AppData\Roaming\Typora\typora-user-images\1551762936696.png)

对于一般的二叉树，现将其升级为完全二叉树，不存在的节点标记为NULL，然后进行数组存储。

当然，使用二叉链表则更为简单，所谓二叉链表，就是指的带有两个孩子指针域和一个数据域的链表。

```c++
typedef struct BiTNode
{
    TElemType data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;
```

#### ==遍历==

##### 前序遍历

首先明确一下，树的三种遍历方式的时间复杂度都是$O(n)$，而空间复杂度为$O(\lg n)$，因为每个结点都只访问一遍，而访问一个结点时，其上层的结点需要入栈，空间复杂度就是树的高度，所以是$O(\lg n)$。使用递归的思想理解这三种遍历方式最好，直接看代码理解。

```c++
void PreOrderTraverse(BiTree T)
{
    if (T==NULL)
        return;
    cout << T->data<<endl; //先访问
    PreOrderTraverse(T->lchild); //进入左子树
    PreOrderTraverse(T->rchild); //从左字树跳出后，进入右子树
}
```

![1551764140203](C:\Users\邢富\AppData\Roaming\Typora\typora-user-images\1551764140203.png)

可以看出，肯定是先访问根节点，再访问其子树。

##### 中序遍历

可以理解为，当一个结点的没有左子树（即叶节点），或者左子树上的结点都已访问，那么才开始访问这个结点，访问完之后立即进入该节点的右子树。如果没有右子树，或者右子树的结点也已经访问完了，那么就跳到上一级，先访问上一级的结点，然后进入其右子树。

中序遍历其实最简答，把握最本质的，那就是，肯定是结点左边的访问结束，才开始访问结点，结点才开始访问，结点的右子树都在结点后面。

例如下图，能够确定的顺序有 G-D-H, B-A-C, E-C-F, E-I，然后把G-D-H看做B的左子树，把E-C-F看做A的右子树，可以很快写出顺序为：

G-D-H-B-A-E-I-C-F

![1551764173380](C:\Users\邢富\AppData\Roaming\Typora\typora-user-images\1551764173380.png)

##### 后序遍历

当一个结点没有左子树，也没有右子树的时候才开始访问它，或者它的左子树和右子树都已被访问，就开始往上一层移动。

![1551764204558](C:\Users\邢富\AppData\Roaming\Typora\typora-user-images\1551764204558.png)

##### 层序遍历

层序遍历实现比较困难，但是理解非常简单，最符合直观理解

![1551764260272](C:\Users\邢富\AppData\Roaming\Typora\typora-user-images\1551764260272.png)

##### 常考题目

给定前序遍历和中序遍历，求后序遍历。

这样的题目，首先确定根节点，必定是前序遍历的第一个，然后根据中序遍历，确定根节点的左右子树元素。根据前序判断哪个元素更高一层，更靠左，根据中序遍历来在所有选择中选出正确的那个。

经典题目：

1. 前序 ABCDEF，中序 CBAEDF--->后序 CBEFDA。

2. 中序 ABCDEF，后序 BDCAFGE--->前序 EACBDGF。

注意：

* 已知前序和中序，或者已知后序和中序，可以确定唯一的二叉树；
* 但是，已知前序和后序，不能确定唯一的二叉树。
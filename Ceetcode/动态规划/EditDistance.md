这一题的动态规划过程很难理解，必须要理清思路，才能写出正确的代码。

定义状态 `dp[i][j]` 为将词 word1[0,...i) 转换为 word2[0,...j) 所需要的操作次数。对于初始情况，将一个词转换为空串，需要将其全部删除，需要的次数就是词的长度，因此 `dp[i][0]=i`。同样地，将一个空串转换为一个词，需要逐个插入字母 `dp[0][j]=j`。

对于一般的词的转换，考虑情况 word1[0,...i) to word2[0,...j)，将问题分为子问题，假设已经知道将 word1[0,...i-1)转换为 word2[0,...j-1)的操作数，即 `dp[i-1][j-1]`，如果 word[i-1]==word[j-1]，那么显然不需要进行操作，直接有 `dp[i][j]=dp[i-1][j-1]`。

如果 word1[i-1]!=word2[j-1]，那么可以通过以下三种方式完成转换：

1. 直接将 word[i-1]替换为 word2[j-1]，那么  `dp[i][j]=dp[i-1][j-1]+1`;
2. 如果word1[0,...i-1)=word2[0...j)，也就是说这时候使用删除更方便，直接将 word1[i-1]删掉， `dp[i][j]=dp[i-1][j]+1`，这时问题转换为删掉这个i-1后的转换问题；
3. 如果 word1[0,...i)=word2[0,...j-1)，也就是说word1少了一个字母，直接在后面加一个 word2[j-1]就行了， `dp[i][j]=dp[i][j-1]+1`，相当于问题转换为了word1转换为没有这个字母的 word2问题。

上面三种情况究竟使用哪个更好，直接比较  `dp[i-1][j], dp[i][j-1], dp[i-1][j-1]`三者的大小即可，不同的取法代表着不同的操作，而具体的操作是不需要我们去显式地选择的。
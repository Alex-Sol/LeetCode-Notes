这一题使用了两个动态规划，首先用一维的dp[n]表示子串的最小划分数，其中 dp[i]表示 子串[0,i]（注意这里是闭区间）的化分数，初始值为 dp[i]=i，因为最坏的情况是全部划分为长度为1的字母，然后可以在区间 [0,i] 内使用 j遍历，尝试将子串划分为两个部分 [0,j-1] [j,i]，如果我们已经知道了 dp[j-1]那么如果后半部分子串 [j,i] 为回文子串，那么 dp[i] = min(dp[i],dp[j-1]+1)，至于判断子串的方法，不能对每一个子串执行 isPalindrome函数，而是应该使用二维动态规划表，表求解的方向应该和 [0,i] [j,i]的方向一致。

这里的核心代码为：

```c++
for(int i=0;i<n;i++){
    dp[i] = i;
    for(int j=0;j<=i;j++){
        if(s[i]==s[j] && (i-j<2 || p[j+1][i-1])){
            p[j][i] = true;
            dp[i]= (j==0)?0:min(dp[i],dp[j-1]+1);
        }
    }
}
```

这里注意 `i-j<2`的用法，和之前`longestPalindromeSubstring`里对于 `dp[i][i]=1`的初始化是一样的，对于任意的单字符，动态表的值为`true`，这里的写法更加简便。

另外当 `j==0`的时候，相当于[j,i]为空，这时表示[0,i]不能划分出任何的回文子串，所以我们直接令 dp[i]=0，不管[0,i] 本身是不是回文串，不划分就是0 cut。
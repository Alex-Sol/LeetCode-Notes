[TOC]



##### 归并排序

使用分治法的思想解决排序问题，将排序好的子数组合并为新的有序数组。这里分治法的思想体现的很明显，回想一下算法导论里的树形分析法，每一层树的结点所包含的元素的总和就是一个全体数组，而这个树的深度为$\lg n$，这个结构很适合并行操作，每层的结点间的排序可以并行操作，合并所需的空间复杂度最大为一层的元素总和，也就是$O(n)$。所以有以下结论：

>最优时间复杂度：$O(n\lg n)$
>
>最坏时间复杂度：$O(n\lg n)​$
>
>最坏空间复杂度：$O (n) ​$

归并排序属于 **稳定排序** **，out-place sort**排序。

##### 堆排序

> 最优时间复杂度：$O(n\lg n)​$
>
> 最坏时间复杂度：$O(n\lg n)​$

堆排序属于 **不稳定排序**，**In-place sort** 排序。

堆排序不适合适用于个数少的序列，因为初试构建堆需要时间。

>例题1
>
>编写算法，从10亿个浮点数中，选出其中最大的10000个。
>
>解：典型的Top K问题，用堆是最简答的思路。建一个10000个大小的小顶堆，然后将10亿个数依次读取，大于堆顶，则替堆顶，做一次调整。结束之后，小顶堆中存放的树就是所求的数。

>例题2
>
>设计一个数据结构，其中包含两个函数：1.插入一个数字；2.获得中位数。并且估计时间复杂度。
>
>解：使用大顶堆和小顶堆存储。大顶堆存储较小的一半数字，使用小顶堆存储较大的一半数字。插入数字时，在$O(\log n)​$ 时间内将该数字插入到相应的堆中，并且适当移动根节点以保持两个堆的数字相等（或者相差为1）。获取中数时，直接去两个堆顶元素，时间为$O(1)​$。

##### 快速排序

> 最优时间复杂度：$O(n\lg n)​$
>
> 最坏时间复杂度：$O(n^2)​$

快速排序属于 **不稳定排序**，**In-place sort** 排序。快速排序的时间复杂度只要和选取的pivot的位置有关，如果很倒霉，每次选取的pivot都是最大值，那么相当于分治法演变为了
$$
T(n)=T(n-1)+\Theta
$$
那么复杂的自然变为$O(n^2)$，但一般情况下，都会是对半分，从而达到$O(n\lg n)​$。

>关于快速排序的改进，主要是分为三个方面：
>
>1. 基准元素的选择：固定位置和随机位置的效果都不是很好，最好的改进是使用“三数取中”法，一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准（枢纽）元素。
>
>2. 当待排序序列的长度分割到一定的大小后，使用插入排序。
>3. 在一次分割结束后，可以把与基准元素相等的元素聚到一起，继续下次分割时，不用再对与key相等的元素进行分割。

##### 三大排序对比

* 最坏时间复杂度：堆排序和归并排序的最坏时间复杂度为$O(n\lg n)$，这点是优于快排的，但是一般状况下，快排还是比较快。

* 空间复杂度：快排需要$O(\lg n)$的空间用来记录分割点（快排使用递归，需要栈的支持，栈的大小最多是n（即每次都是最差情况，退化为冒泡排序），所以空间复杂度一般记为$O(n)$），归并排序需要$\Omega(n)$的空间复杂度，堆排序的空间复杂度为常数。

* 稳定性：快排和堆排序是不稳定排序，而归并排序是稳定排序。

* 存储和访问：归并排序可以轻易地被采用在链表和存储在慢速访问的磁盘或者网络连接山的非常巨大的数列。

* 和插入排序对比：插入排序在数组排好序时，最优时间复杂度为$O(n)$，但是此时快排确是最坏情况，因为分割点在两端。插入排序时间复杂度为$O(n^2)​$，其复杂度和逆序对的个数是一样的，比较适合于“少量元素的排序”。另外，插入排序是链表排序的首选。

  >插入排序是 **稳定的**，**in-place** 算法。

##### 比较排序算法的本质

>理解比较排序的本质：n 个元素，可能的顺序共有$n!$ 种，每一次比较可以排除一半的可能性，即排除掉a<b或者a>b的可能。要想完成一次排序，需要通过x 次比较，使得 $2^x>n!$，于是$x> \log_2(n!)$，使用斯特林公式$n!= \sqrt{2\pi n}(\frac{n}{e})^n$，代入之后，自然得到x 的下限和 $n\log n$是同阶的。任何通过比较来进行排序的算法时间复杂度都不会超过这个极限，只能无限逼近，包括快排、归并、堆排序。

